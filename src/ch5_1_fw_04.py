n_vertices = 18
edges = [
  (0, 1, 686), (0, 2, 429), (0, 5, 232), (0, 9, 319), (0, 13, 193), 
  (1, 8, 180), (1, 10, 345), (1, 11, 100), (1, 13, 302), (1, 17, 374), 
  (2, 10, 83), (2, 11, 298), (2, 12, 730), (2, 17, 96), (3, 12, 332), 
  (3, 13, 494), (3, 17, 342), (4, 7, 378), (4, 8, 374), (4, 14, 235), 
  (4, 15, 214), (5, 12, 320), (5, 17, 302), (6, 15, 208), (6, 16, 190), 
  (7, 15, 240), (8, 11, 194), (8, 13, 709), (9, 12, 62), (10, 11, 254), 
  (10, 13, 249), (10, 17, 97), (11, 14, 323), (12, 13, 140), (12, 14, 572), 
  (12, 17, 494), (13, 14, 383), (13, 17, 479), (14, 16, 694), (15, 16, 392)
]

# 함수는 사용하지 않고 작성한다 (키워드 def 를 사용하지 않는다)
# 결과는 18x18 의 표 형태로 비용을 출력한다.

# 0. Edge List -> Adj Matrix 형태로 변환 (하지 않음)
# 1. 2차원 배열 D 에 0, 비용, inf 중 하나를 넣어 초기화
# 2. 경유지를 저장할 2차원배열 P 를 초기화
INF = float('inf')
D = [[ INF for _ in range(n_vertices) ] for _ in range(n_vertices) ] # n x n 의 INF
P = [[ -1 for _ in range(n_vertices) ] for _ in range(n_vertices) ] # n x n 의 INF
for i in range(n_vertices):
    # ... # 0 이 들어가는 경우 (출발지/도착지 같은 경우)
for u,v,w in edges:
    # ... # 알려진 비용
    # ... 
print(D)
# 3. k 를 0 부터 17 까지 변환하며 비용 갱신
for k in range(n_vertices):
  for i in range(n_vertices):
    if i == k: continue
    for j in range(n_vertices):
      if j == i or j == k: continue
# 4. (opt) 갱신할 때 i 부터 j 까지 가려면 k 로 가야한다 라는 내용도 추가 저장
# 5. D 의 내용을 출력한다
for i in range(n_vertices):
  for j in range(n_vertices):
    print(f'{D[i][j]:4d} ', end='')
  print()

def path(i, j):
  k = P[i][j]
  if k < 0: return f'->{j}'
  return f'{path(i,k)}{path(k,j)}'

for i in range(n_vertices):
  print(f'[{i}] ', end='')
  for j in range(n_vertices):
    if i == j: continue
    print(f'{i}{path(i,j)}, ', end='')
  print()

#    0  495  429  665  811  232 1233 1189  675  319  442  595  333  193  576 1025 1270  525 
#  495    0  398  716  554  676  976  932  180  504  345  100  442  302  423  768 1117  374 
#  429  398    0  438  856  398 1278 1234  492  534   83  298  472  332  621 1070 1315   96 
#  665  716  438    0 1090  644 1512 1468  887  394  439  693  332  472  855 1304 1549  342 
#  811  554  856 1090    0 1043  422  378  374  820  812  558  758  618  235  214  606  909 
#  232  676  398  644 1043    0 1465 1421  847  382  399  653  320  425  808 1257 1502  302 
# 1233  976 1278 1512  422 1465    0  448  796 1242 1234  980 1180 1040  657  208  190 1331 
# 1189  932 1234 1468  378 1421  448    0  752 1198 1190  936 1136  996  613  240  632 1287 
#  675  180  492  887  374  847  796  752    0  684  448  194  622  482  517  588  980  545 
#  319  504  534  394  820  382 1242 1198  684    0  451  604   62  202  585 1034 1279  548 
#  442  345   83  439  812  399 1234 1190  448  451    0  254  389  249  577 1026 1271   97 
#  595  100  298  693  558  653  980  936  194  604  254    0  542  402  323  772 1017  351 
#  333  442  472  332  758  320 1180 1136  622   62  389  542    0  140  523  972 1217  486 
#  193  302  332  472  618  425 1040  996  482  202  249  402  140    0  383  832 1077  346 
#  576  423  621  855  235  808  657  613  517  585  577  323  523  383    0  449  694  674 
# 1025  768 1070 1304  214 1257  208  240  588 1034 1026  772  972  832  449    0  392 1123 
# 1270 1117 1315 1549  606 1502  190  632  980 1279 1271 1017 1217 1077  694  392    0 1368 
#  525  374   96  342  909  302 1331 1287  545  548   97  351  486  346  674 1123 1368    0 

# 6. (opt) 12x11 의 경로들을 모두 출력해도 좋다. 이 경우 함수를 이용한다

# 6번은 다음과 같은 형태로 출력한다.
# [0] 0->13->1, 0->2, 0->13->12->3, 0->13->14->4, 0->5, 0->13->14->4->15->6, 0->13->14->4->7, 0->13->1->8, 0->9, 0->13->10, 0->13->1->11, 0->13->12, 0->13, 0->13->14, 0->13->14->4->15, 0->13->14->16, 0->2->17, 
# [1] 1->13->0, 1->11->2, 1->17->3, 1->8->4, 1->17->5, 1->8->4->15->6, 1->8->4->7, 1->8, 1->13->12->9, 1->10, 1->11, 1->13->12, 1->13, 1->11->14, 1->8->4->15, 1->11->14->16, 1->17, 
# [2] 2->0, 2->11->1, 2->17->3, 2->11->14->4, 2->17->5, 2->11->14->4->15->6, 2->11->14->4->7, 2->11->8, 2->10->13->12->9, 2->10, 2->11, 2->10->13->12, 2->10->13, 2->11->14, 2->11->14->4->15, 2->11->14->16, 2->17, 
#  ... (하략)

