questions = [
  [4, 19, 13, 10, 13, 14, 3, 9, 5],
  [11, 13, 13, 19, 12, 20, 16, 4, 5, 19],
  [18, 6, 7, 19, 9, 11, 5, 19, 8, 13],
  [3, 19, 11, 3, 5, 5, 11, 5, 16],
  [6, 10, 10, 11, 17, 18, 8, 7, 10, 6],
  [14, 4, 13, 16, 18, 12, 10, 8, 20, 4],
]

# 출력은 다음과 같은 형태로 한다.
# sizes=[4, 19, 13, 10, 13, 14, 3, 9, 5]
# 2490 (((4x19) x ((19x13) x ((13x10) x ((10x13) x ((13x14) x (14x3)))))) x ((3x9) x (9x5)))
# sizes=[11, 13, 13, 19, 12, 20, 16, 4, 5, 19]
# 6604 (((11x13) x ((13x13) x ((13x19) x ((19x12) x ((12x20) x ((20x16) x (16x4))))))) x ((4x5) x (5x19)))
# sizes=[18, 6, 7, 19, 9, 11, 5, 19, 8, 13]
# 5207 (((18x6) x ((6x7) x (((7x19) x (19x9)) x ((9x11) x (11x5))))) x (((5x19) x (19x8)) x (8x13)))
# sizes=[3, 19, 11, 3, 5, 5, 11, 5, 16]
# 1416 (((((3x19) x (19x11)) x (11x3)) x ((((3x5) x (5x5)) x (5x11)) x (11x5))) x (5x16))
# sizes=[6, 10, 10, 11, 17, 18, 8, 7, 10, 6]
# 6090 ((((((((6x10) x (10x10)) x (10x11)) x (11x17)) x (17x18)) x (18x8)) x (8x7)) x ((7x10) x (10x6)))
# sizes=[14, 4, 13, 16, 18, 12, 10, 8, 20, 4]
# 4640 ((14x4) x (((((((4x13) x (13x16)) x (16x18)) x (18x12)) x (12x10)) x (10x8)) x ((8x20) x (20x4))))
# ...

def cmm():
  global sizes, C, P
  print(f'{sizes=}')
  mc = len(sizes) - 1        # mc=matrix count. 행렬의 수 이다
  C = [[ 0 for _ in range(...) ] for _ in range(...) ] # C[s][e] 에는 s 부터 e 까지 곱할 때의 최소연산수를 담는다 # 0으로 초기화
  P = ...                    # P[s][e] 에는 s 부터 e 까지 곱할 때 마지막 곱셈을 할 인덱스를 담는다
  for sub in range(2, mc + 1): # 부분문제의 크기. 2부터 mc 까지 진행한다
    for s in range(1, mc - sub + 1 + 1): # 부분문제가 시작되는 위치
      e = s + sub - 1            # 부분문제가 끝나는 위치
      ...             # s부터 e까지의 초기값을 넣고
      for k in range(s, e):    # k 를 s 부터 e 까지 옮겨가면서 마지막 곱셈을 어디서 할지 비교한다
        ....          # k 번째에서 마지막 곱셈을 할 경우
        if ....:      # 이득이 있다면
          ....        # 횟수를 저장한다
          ....        # 마지막 곱셈 위치를 저장한다
  print(C[1][mc], result(1, mc)) # 최종적으로 1 부터 mc 까지 곱할 때의 결과를 출력한다

def result(s, e):
  global sizes, C, P
  if s == e:                               # 시작과 끝이 같다면 행렬의 곱셈이 아닌 행렬 1개의 크기
    return f'({sizes[s-1]}x{sizes[s]})'
  p = P[s][e]                              # 마지막 곱셈의 위치
  if p == 0: return ''          # 만약 여기 걸리면 버그이다. 이럴리가 없다
  a = result(s, p)    # s 부터 p 까지의 곱셈 문자열
  b = result(p+1, e)  # p+1 부터 e 까지의 곱셈 문자열
  return f'({a} x {b})'         # 두 결과끼리의 곱셈 형태로 리턴한다

for q in questions:
  sizes = q
  cmm()
