n_vertices = 18
edges = [
  (0, 9, 210), (0, 13, 498), (0, 16, 606), (1, 2, 203), (1, 8, 217), 
  (1, 16, 537), (2, 8, 322), (2, 16, 269), (3, 4, 189), (3, 7, 534), 
  (3, 8, 466), (3, 11, 371), (3, 12, 284), (3, 17, 407), (4, 7, 193), 
  (4, 11, 273), (4, 12, 181), (4, 15, 316), (5, 6, 224), (5, 14, 178), 
  (5, 17, 628), (6, 10, 202), (6, 11, 448), (6, 17, 272), (7, 11, 142), 
  (7, 12, 141), (7, 15, 249), (9, 13, 457), (9, 16, 281), (10, 17, 405), 
  (11, 12, 215), (11, 17, 176), (12, 15, 255), (12, 17, 373), (13, 14, 241), 
  (13, 16, 265)
]

# 함수는 사용하지 않고 작성한다 (키워드 def 를 사용하지 않는다)
# 결과는 18x18 의 표 형태로 비용을 출력한다.

# 0. Edge List -> Adj Matrix 형태로 변환 (하지 않음)
# 1. 2차원 배열 D 에 0, 비용, inf 중 하나를 넣어 초기화
# 2. 경유지를 저장할 2차원배열 P 를 초기화
INF = float('inf')
D = [[ INF for _ in ... ] for _ in ... ] # n x n 의 INF
P = [[ -1 for _ in ... ] for _ in ... ] # n x n 의 INF
for i in range(n_vertices):
    # ... # 0 이 들어가는 경우 (출발지/도착지 같은 경우)
for u,v,w in edges:
    # ... # 알려진 비용
    # ... 
print(D)
# 3. k 를 0 부터 17 까지 변환하며 비용 갱신

...
  ...
    ...
      ...

# 4. 갱신할 때 i 부터 j 까지 가려면 k 로 가야한다 라는 내용도 추가 저장
      ...

# 5. D 의 내용을 출력한다
for i in range(n_vertices):
  for j in range(n_vertices):
    print(f'{D[i][j]:4d} ', end='')
  print()

def path(i, j):
  k = P[i][j]
  if k < 0: return f'->{j}'
  return f'{path(i,k)}{path(k,j)}'

for i in range(n_vertices):
  print(f'[{i}] ', end='')
  ...
    ...
    print(f'{i}{path(i,j)}, ', end='')
  print()

#    0  963  760 1548 1737  917 1141 1731 1082  210 1343 1589 1786  498  739 1980  491 1413 
#  963    0  203  683  872 1156 1362 1065  217  753 1495 1054  967  737  978 1188  472 1090 
#  760  203    0  788  977  953 1177 1170  322  550 1379 1159 1072  534  775 1293  269 1195 
# 1548  683  788    0  189  903  679  382  466 1338  812  371  284 1322 1081  505 1057  407 
# 1737  872  977  189    0  945  721  193  655 1527  854  273  181 1364 1123  316 1246  449 
#  917 1156  953  903  945    0  224  814 1275  876  426  672  869  419  178 1063  684  496 
# 1141 1362 1177  679  721  224    0  590 1145 1100  202  448  645  643  402  839  908  272 
# 1731 1065 1170  382  193  814  590    0  848 1690  723  142  141 1233  992  249 1439  318 
# 1082  217  322  466  655 1275 1145  848    0  872 1278  837  750  856 1097  971  591  873 
#  210  753  550 1338 1527  876 1100 1690  872    0 1302 1548 1622  457  698 1843  281 1372 
# 1343 1495 1379  812  854  426  202  723 1278 1302    0  581  778  845  604  972 1110  405 
# 1589 1054 1159  371  273  672  448  142  837 1548  581    0  215 1091  850  391 1356  176 
# 1786  967 1072  284  181  869  645  141  750 1622  778  215    0 1288 1047  255 1341  373 
#  498  737  534 1322 1364  419  643 1233  856  457  845 1091 1288    0  241 1482  265  915 
#  739  978  775 1081 1123  178  402  992 1097  698  604  850 1047  241    0 1241  506  674 
# 1980 1188 1293  505  316 1063  839  249  971 1843  972  391  255 1482 1241    0 1562  567 
#  491  472  269 1057 1246  684  908 1439  591  281 1110 1356 1341  265  506 1562    0 1180 
# 1413 1090 1195  407  449  496  272  318  873 1372  405  176  373  915  674  567 1180    0 

# 6. 18x17 의 경로들을 모두 출력한다
# [0] 0->9->16->2->1, 0->9->16->2, 0->9->16->2->8->3, 0->9->16->2->8->3->4, 0->13->14->5, 0->13->14->5->6, 0->13->14->5->6->11->7, 0->9->16->2->8, 0->9, 0->13->14->5->6->10, 0->13->14->5->6->11, 0->13->14->5->6->17->12, 0->13, 0->13->14, 0->13->14->5->6->11->7->15, 0->9->16, 0->13->14->5->6->17, 
# [1] 1->2->16->9->0, 1->2, 1->8->3, 1->8->3->4, 1->2->16->13->14->5, 1->8->3->17->6, 1->8->3->4->7, 1->8, 1->2->16->9, 1->8->3->17->10, 1->8->3->11, 1->8->3->12, 1->2->16->13, 1->2->16->13->14, 1->8->3->4->15, 1->2->16, 1->8->3->17, 
# [2] 2->16->9->0, 2->1, 2->8->3, 2->8->3->4, 2->16->13->14->5, 2->16->13->14->5->6, 2->8->3->4->7, 2->8, 2->16->9, 2->16->13->14->5->6->10, 2->8->3->11, 2->8->3->12, 2->16->13, 2->16->13->14, 2->8->3->4->15, 2->16, 2->8->3->17, 
#  ... (하략)

